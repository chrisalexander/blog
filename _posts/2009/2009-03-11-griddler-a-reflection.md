---
layout: post
heading: 'Griddler, a reflection'
categories: uni
---

This project has easily been the largest code project I have worked on, and the challenges of it were not what I was expecting: it turns out I'm quite good at spotting errors and reducing them in code before its compiled, so compilation and syntactical errors were not as often an occurance as I was expecting. The challenges were, instead, on the correct implementation of designs for functions, and the correct designs of functions themselves. In some cases, I knew what I wanted a function to do, and had trouble constructing code that actually did it (even though the code that didn't perform the task correctly was still "correct" as far as the compiler was concerned). In other cases, I wasn't quite sure exactly how to go about achieving a certain task, which could only be overcome by thinking and reasoning, and lots of bits of paper with even more scribbled squares and numbers. Another problem was caused by the excessive volume of code, which I tried to minimise as much as possible by organising functions and headers in a logical pattern, was physically finding the function I wanted to edit. Usually I'm extremely adverse to commenting code at all, but even I had to write some comments to remind me where to find the function I was actually calling, and what all these nested if and for loops actually did. Having never written quite as much code as this, I could usually remember what was going on, but it turns out that if you wrote a function 3 weeks ago and have written 1500 lines of something almost completely unrelated since then, it becomes a bit trickier to remember!This project has definitely improved me as a programmer, as I now understand a lot better why comments are required in so much code and it taught me (in some cases, the hard way) how the best way to do this is. I've also learnt a lot about structuring code, and developed my knowledge on classes, objects, and their most effective use.

All in all, I don't think there are many improvements that could be made to the actual project itself. The two choices presented were different and varied enough so everyone could have a good attempt at one. The only criticism I could find was that a little more support could be provided in regards to how you could attempt the project (I realise this is possibly to keep it open-ended though) and a bit more in the way of guidance towards how the write-up should be completed as I found it complex to decrypt and inconsistent with the recommended structure.

While I could improve my program with a GUI and better solving abilities, I think it has reached a suitable stage for the amount of time I've had to spend on it, and I'm really pleased with how it has turned out.